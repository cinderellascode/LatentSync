import cv2
import numpy as np
from gfpgan import GFPGANer
from basicsr.archs.codeformer_arch import CodeFormer

def apply_superres(image, method):
    """
    Apply super-resolution to the image using the specified method.
    """
    if method == "GFPGAN":
        restorer = GFPGANer(
            model_path="gfpgan.pth",
            upscale=2,  # Adjust based on resolution ratio
            arch="clean",
            channel_multiplier=2,
            bg_upsampler=None,
        )
        _, _, output = restorer.enhance(image, has_aligned=False, only_center_face=False, paste_back=True)
    elif method == "CodeFormer":
        restorer = CodeFormer(
            dim_embd=512,
            codebook_size=1024,
            n_head=8,
            n_layers=9,
            connect_list=["32", "64", "128", "256"],
        )
        output = restorer.enhance(image, fidelity_ratio=0.5)  # Adjust fidelity_ratio as needed
    else:
        raise ValueError(f"Unsupported super-resolution method: {method}")
    return output

def main():
    # Load input video
    input_video = "input_video_with_audio.mp4"
    cap = cv2.VideoCapture(input_video)

    # Load lip-synced video (generated by LatentSync)
    lipsynced_video = "lipsynced.mp4"
    lip_cap = cv2.VideoCapture(lipsynced_video)

    # Get video properties
    width = int(cap.get(cv2.CAP_PROP_FRAME_WIDTH))
    height = int(cap.get(cv2.CAP_PROP_FRAME_HEIGHT))
    fps = cap.get(cv2.CAP_PROP_FPS)

    # Create output video writer
    output_video = "output_video.mp4"
    fourcc = cv2.VideoWriter_fourcc(*"mp4v")
    out = cv2.VideoWriter(output_video, fourcc, fps, (width, height))

    # Process each frame
    while True:
        ret, frame = cap.read()
        ret_lip, lip_frame = lip_cap.read()
        if not ret or not ret_lip:
            break

        # Detect resolution mismatch
        lip_height, lip_width = lip_frame.shape[:2]
        if lip_height < height or lip_width < width:
            # Apply super-resolution to the lip-synced frame
            lip_frame = apply_superres(lip_frame, method=args.superres)

        # Combine the frames
        combined_frame = frame.copy()
        combined_frame[0:lip_height, 0:lip_width] = lip_frame

        # Write the output frame
        out.write(combined_frame)

    # Release resources
    cap.release()
    lip_cap.release()
    out.release()

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("--superres", type=str, default="none", help="Super-resolution method (GFPGAN/CodeFormer)")
    args = parser.parse_args()
    main()